# 数据类型转换



## 背景

有一些开发语言是强制类型的语言。需要提前声明（告诉）数据类型，才能定义变量。

并且，还有一些语言有更诡异的要求：整型只能与整型相加、浮点只能与浮点进行处理。

用人类的语言解释：

> 人只能和人在一起，动物只能和动物在一起。

而Python不是强类型的语言，使用前不需要声明数据类型。在用的时候直接使用即可。

本章为数据类型的相关的最后一章，数据类型转换有两种方式：

1. 强制类型转换（显式转换）；
2. 自动类型转换（隐式转换）。

回顾一下：

> type( ) 函数可以显示当前变量的类型，以字符串的形式进行输出。



## 1. 强制类型转换（显示转换）

| 函数      | 说明                                                | 掌握级别 |
| --------- | --------------------------------------------------- | -------- |
| str( )    | 强制转换为字符串                                    | 重点     |
| int( )    | 强制转换为整型                                      | 重点     |
| float( )  | 强制转换为浮点                                      | 重点     |
| set( )    | 强制转为集合                                        |          |
| list( )   | 强制转为列表                                        |          |
| tuple( )  | 强制转为元组                                        |          |
| long( )   | 强制转为长整型                                      |          |
| chr( )    | 将一个整数转换为一个字符                            |          |
| unichr( ) | 将一个整数转换为Unicode字符                         |          |
| eval( )   | 用来计算在字符串中的有效Python表达式,并返回一个对象 | 重点     |
| hex( )    | 将一个整数转换为一个十六进制字符串                  |          |
| ord( )    | 将一个字符转换为它的整数值                          |          |
| oct( )    | 将一个整数转换为一个八进制字符串                    |          |
| repr( )   | 转换为表达式字符串                                  |          |

注：上面标注重点的内容需要掌握。其他的：您需要提高“搜商”（SQ），需要的时候借用搜索查到即可。

此处使用格式的语法规定：

>  新值 = 函数( 旧值 )

我们将重点的几个函数做一下实验看看结果。

~~~python
#coding=utf-8
#声明一个字符串的5
str = '5'
print(type(str))
#强制转换为整型
my_int = int(str)
print(type(my_int))
print(my_int)

#我们强制转换为浮点看一下结果
flt = float(str)
print(type(flt))
print(flt)

~~~

看一下运行结果：

~~~
<type 'str'>
<type 'int'>
5
<type 'float'>
5.0

~~~

结论：

str 为字符串的5；

在 my_int 里面被强制转为了整型 int类型。

在flt 变量里面被强制转为了浮点 float类型。



特殊的eval， eval 可以将字符串转为Python代码进行执行，我们看看下面的一个字符串： "x + 2"。 这样一个字符串是不是可以执行出对应的计算结果。

~~~python
x = 5

print(eval("x + 2"))
~~~

运行结果：

~~~
7
~~~

结论：

x = 5。

而在 eval 里面 的字符串 x + 2 被当成Python的代码执行了。



> 注：其他一些如 ord 、oct这些函数自己做实验玩玩即可。



## 2. 自动类型转换

在某些时候发生运算和操作的时候，一些类型会自动的发生变化。我们就叫作：自动类型转换，也叫作：隐式转换。

自动类型转换一般是针对数值类型（整型、浮点），一般发生在判断和运算时。

其他的一些值在参与判断和运算的时候，也会被转换为布尔类型。



### 2.1 各种类型判断时为False的自动类型转换

在Python里面 布尔类型自动转换有下列的一些情况：

| 类型   | 说明                   |
| ------ | ---------------------- |
| 0      | 整型0，判断时为假      |
| 0.0    | 浮点的0.0 ，判断时为假 |
| ""     | 空字符串，判断时为假   |
| ()     | 空元组，判断时为假     |
| [ ]    | 空列表，判断时为假     |
| set( ) | 空集合，判断时为假     |
| { }    | 空字典，判断时为假     |
| None   | 空值，判断时为假       |



我们直接贴代码看一下运行结果吧：

~~~python
#coding=utf-8

#空字符串类型
str = ''
if str:
    print("执行真区间")
else:
    print("执行假区间")


#None类型
my_no = None
if my_no:
    print("执行真区间")
else:
    print("执行假区间")

#整型的0
my_int = 0
if my_int:
    print("执行真区间")
else:
    print("执行假区间")


#空的集合
my_set = set()
if my_set:
    print("执行真区间")
else:
    print("执行假区间")
~~~

运行结果：

~~~
执行假区间
执行假区间
执行假区间
执行假区间
~~~

结论：

表格里的各种情况基本上都被论证为 自动类型转换为了布尔值中的假了。



### 2.2 运算时的布尔类型自动转换



| 情况            | 说明         |
| --------------- | ------------ |
| True 与整型相加 | True视为1    |
| False与整型相加 | False视为0   |
| 整型与浮点相加  | 整型视为浮点 |



~~~python

result = 1 + True

x = 2 + False

print(type(result))
print(result)

print(type(x))
print(x)
~~~

看看运行结果吧：

~~~
<type 'int'>
2
<type 'int'>
2
~~~

结论与表格中的结论一致。



再看一下整型视为浮点的情况：

~~~python
x = 5
y = 5.2

result = x + y

print(type(result))
print(result)
~~~

看看运行结果：

~~~
x = 5
y = 5.2

result = x + y

print(type(result))
print(result)

~~~

结论：整型被转为了浮点，参与了运算。



